FreeMail: A cloud-based OpenPGP-compliant mail

Usage:
In the freemail directory, simply run the 'rails server' command to start the web server.
To enable the IMAP daemon, in a seprate terminal, run mail_room -c 'config/gmail.yml'.
However, the SMTP sending protocl fails in the Zoo due to connection rules that prevent outgoing connections on specific ports.
However, a separate server is set up at 54.200.28.36:3000 which can be used to test it. 

Motivation: 
  Existing OpenPGP plugins are often not faithful to the standard, frequently use MIME types that are not standard and cannot faithfully decrypt mails that are encrypted by other plugins. In addition, the fundamental limitation of these plugins is that they are all local processes. This makes them unsuitable for cloud-hosted services like GMail or Outlook.com which are meant to be accessed from many different computers.

Parts:
  I built a Rails server that is hosted on an Amazon Cloud server that serves the HTTP frontend that allows users to login, view, decrypt and encrypt their email. Users can have multiple mailboxes that allow them to get email from multiple email accounts into the same Freemail account. The rails server uses a SQLite database to store all the information. The server also has an SMTP gateway that connects to the GMail SMTP server to send emails through it.
  There is a separate IMAP daemon that monitors a list of GMail addresses and retrieves emails from the GMail mailbox.

Encryption:
  Each user has a list of public keys that are stored in the form of 'Contacts'. The user can send an encrypted email to any of these contacts. The user also has the ability to upload his own private key onto the service. This will allow the user to decrypt all the emails addressed to her.
  The encryption scheme implementation used is GnuPG, which is an open-source implementation of the OpenPGP standard, which is the most widely-used PGP standard used. 
  The user is required to generate his or her own GPG private and public keys and optionally share it on a Public Key Server.
  She then uploads her private key to the Freemail server. This key is encrypted using the symmetric version of the GPG algorithm, with the user's Freemail password serving as the symmetric key passphrase.
  Other users who wish to email her can then download her public key from a key server and then upload it as a contact.
  Using the web interface, they can then encrypt the message using the public key.
  Of course, the user also has the ability to read and send unencrypted emails.

Message Format:
  The email headers are all in plaintext as specified by the OpenPGP standard. The message body is an ASCII-armored PGP block which can then be fed directly into an OpenPGP-compliant decrypter. Currently the service only support plaintext emails, but it is possible to include other MIME types by base64 encoding them and then encrypting them.
  The messages are always decrypted on the fly. They are NEVER stored in decrypted format.
  Once the email arrives at the Freemail server, it is put inside a ‘conversation’. This conversation structure stores the emails as part of a thread of emails. Thus, it is possible to see an entire conversation with a particular contact.

Challenges:
  The most coding intensive part of the project was the construction of the cloud-based email infrastructure to interact with Gmail servers. There were authentication challenges because my Amazon server was located in Oregon. The IMAP connection would be periodically terminated by Gmail.
  I also had to get around the firewall on the SMTP port in the Zoo. This required me to use an Amazon server at address 54.500.28.36.

Extensions:
  1. A clear logical extension would be to support the signing of emails. Indeed, the system already does so, but due to bugs in the implementation of the Ruby GPG library, it does not always deterministically verify the correct sender.
  2. A client-side process could be developed that would allow the generation of PGP keys using a GUI interface. Right now the PGP keys must be generated by the user through the command line, which is not always user-friendly.
  3. A further extension would be to calculate the average response times of different users. In addition, mapping the pattern of responses would allow us to calculate the optimal times to send an email to a particular email.
